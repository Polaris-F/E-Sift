# 接口参考

> **版本**: 2.1.1 | **更新**: 2026-02-11

---

## C++ API

核心接口声明在 `src/cudaSift.h` 中。

### CUDA 初始化

```cpp
void InitCuda(int devNum = 0);
```

初始化指定 GPU 设备。`devNum` 为设备编号（从 0 开始）。

### 图像管理

```cpp
// CudaImage: GPU 图像容器
CudaImage img;
img.Allocate(width, height, iAlignUp(width, 128), false, NULL, hostPtr);
img.Download();   // 从 host 上传到 device
```

- `iAlignUp(width, 128)` 将宽度对齐到 128 字节边界
- `hostPtr` 为 `float*` 类型的灰度图像数据（每像素一个 float）

### SIFT 数据

```cpp
void InitSiftData(SiftData &data, int num = 1024, bool host = false, bool dev = true);
void FreeSiftData(SiftData &data);
```

| 参数 | 说明 |
|------|------|
| `num` | 最大特征点容量 |
| `host` | 是否在主机端分配内存（匹配/单应性需要设为 `true`） |
| `dev` | 是否在设备端分配内存 |

### 临时内存管理

```cpp
float *AllocSiftTempMemory(int width, int height, int numOctaves, bool scaleUp = false);
void   FreeSiftTempMemory(float *memoryTmp);
```

预分配临时内存可避免每次调用 `ExtractSift` 时重复分配，适合批量处理。

### 特征提取

```cpp
void ExtractSift(SiftData &siftData, CudaImage &img,
                 int numOctaves, double initBlur, float thresh,
                 float lowestScale = 0.0f, bool scaleUp = false,
                 float *tempMemory = 0);
```

| 参数 | 说明 | 建议值 |
|------|------|--------|
| `numOctaves` | 金字塔层数 | 3–8，通常 5 |
| `initBlur` | 初始高斯模糊 sigma | 1.0 |
| `thresh` | DoG 响应阈值，越高特征越少但质量越好 | 1.0–10.0 |
| `lowestScale` | 最小检测尺度 | 0.0（检测全部尺度） |
| `scaleUp` | 是否将图像放大 2× 后处理 | `false` |
| `tempMemory` | 预分配的临时内存（可选） | `AllocSiftTempMemory()` 的返回值 |

### 特征匹配

```cpp
double MatchSiftData(SiftData &data1, SiftData &data2);
```

GPU brute-force 匹配。结果写入每个 `SiftPoint` 的 `match` 和 `match_err` 字段。

### 单应性估计

```cpp
double FindHomography(SiftData &data, float *homography, int *numMatches,
                      int numLoops = 1000, float minScore = 0.85f,
                      float maxAmbiguity = 0.95f, float thresh = 5.0f);

int ImproveHomography(SiftData &data, float *homography,
                      int numLoops, float minScore,
                      float maxAmbiguity, float thresh);
```

- `FindHomography`: RANSAC 估计 3×3 单应性矩阵
- `ImproveHomography`: 基于内点的最小二乘优化

### C++ 使用完整示例

```cpp
#include "cudaImage.h"
#include "cudaSift.h"
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>

int main() {
    // 初始化
    InitCuda(0);

    // 读取图像
    cv::Mat limg, rimg;
    cv::imread("data/left.pgm", 0).convertTo(limg, CV_32FC1);
    cv::imread("data/righ.pgm", 0).convertTo(rimg, CV_32FC1);

    int w = limg.cols, h = limg.rows;

    // 上传到 GPU
    CudaImage img1, img2;
    img1.Allocate(w, h, iAlignUp(w, 128), false, NULL, (float*)limg.data);
    img2.Allocate(w, h, iAlignUp(w, 128), false, NULL, (float*)rimg.data);
    img1.Download();
    img2.Download();

    // 提取特征
    SiftData siftData1, siftData2;
    InitSiftData(siftData1, 32768, true, true);
    InitSiftData(siftData2, 32768, true, true);

    float *mem = AllocSiftTempMemory(w, h, 5, false);
    ExtractSift(siftData1, img1, 5, 1.0f, 3.0f, 0.0f, false, mem);
    ExtractSift(siftData2, img2, 5, 1.0f, 3.0f, 0.0f, false, mem);
    FreeSiftTempMemory(mem);

    // 匹配 + 单应性
    MatchSiftData(siftData1, siftData2);

    float homography[9];
    int numMatches;
    FindHomography(siftData1, homography, &numMatches, 10000, 0.0f, 0.80f, 5.0);

    printf("特征: %d / %d, 匹配: %d\n",
           siftData1.numPts, siftData2.numPts, numMatches);

    // 清理
    FreeSiftData(siftData1);
    FreeSiftData(siftData2);
    return 0;
}
```

---

## Python API

Python 绑定通过 pybind11 实现，需编译时开启 `-DESIFT_BUILD_PYTHON=ON`。

### 导入

```python
import sys
sys.path.insert(0, "build/python")
import cuda_sift
```

### SiftConfig — 参数配置

```python
config = cuda_sift.SiftConfig(config_file_path)
```

从 txt 配置文件加载参数。主要属性：

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `max_features` | int | 32768 | 最大特征点数量 |
| `dog_threshold` | float | 1.3 | DoG 响应阈值 |
| `num_octaves` | int | 5 | 金字塔层数 |
| `initial_blur` | float | 1.0 | 初始模糊 sigma |

### SiftExtractor — 特征提取

```python
extractor = cuda_sift.SiftExtractor(config)
features  = extractor.extract(image)   # image: np.float32 灰度图
```

返回字典：

```python
{
    "num_features":  int,           # 特征点数量
    "keypoints":     np.ndarray,    # 坐标 [N, 2] (x, y)
    "descriptors":   np.ndarray,    # 描述子 [N, 128]
    "scales":        np.ndarray,    # 尺度 [N]
    "orientations":  np.ndarray     # 方向 [N]
}
```

### SiftMatcher — 特征匹配

```python
matcher = cuda_sift.SiftMatcher(min_score=0.85, max_ambiguity=0.95)
```

#### 分离式接口（调试友好）

```python
# 步骤 1: 匹配
matches = matcher.match(features1, features2)
# 返回: {"num_matches", "matches", "match_score", "distances"}

# 步骤 2: 单应性估计
result = matcher.compute_homography(matches, features1, features2,
                                    num_loops=1000, thresh=5.0)
# 返回: {"homography", "num_inliers", "score"}
```

#### 集成式接口（性能最优）

```python
result = matcher.match_and_compute_homography(
    features1, features2,
    use_improve=True,    # 启用最小二乘优化
    improve_loops=5,     # 优化迭代次数
    num_loops=1000,      # RANSAC 迭代数
    thresh=5.0           # 内点阈值
)
```

返回字典：

```python
{
    "num_matches":          int,          # 匹配对数量
    "matches":              np.ndarray,   # 匹配索引 [N, 2]
    "match_score":          float,        # 匹配得分
    "homography":           np.ndarray,   # 3×3 单应性矩阵
    "num_inliers":          int,          # 内点数量
    "num_refined_inliers":  int,          # 精炼后内点数（仅 use_improve=True）
    "score":                float         # 单应性得分
}
```

### Python 使用完整示例

```python
import sys, cv2, numpy as np
sys.path.insert(0, "build/python")
import cuda_sift

# 配置 & 初始化
config    = cuda_sift.SiftConfig("config/test_config.txt")
extractor = cuda_sift.SiftExtractor(config)
matcher   = cuda_sift.SiftMatcher()

# 加载图像（float32 灰度图）
img1 = cv2.imread("data/left.pgm", 0).astype(np.float32)
img2 = cv2.imread("data/righ.pgm", 0).astype(np.float32)

# 提取特征
f1 = extractor.extract(img1)
f2 = extractor.extract(img2)
print(f"特征数: {f1['num_features']}, {f2['num_features']}")

# 匹配 + 单应性（一步完成）
result = matcher.match_and_compute_homography(f1, f2)
print(f"匹配: {result['num_matches']}, 内点: {result['num_inliers']}")

# 使用单应性矩阵对齐图像
H = result["homography"]
aligned = cv2.warpPerspective(
    cv2.imread("data/righ.pgm"),
    H.astype(np.float64),
    (img1.shape[1], img1.shape[0])
)
cv2.imwrite("aligned.jpg", aligned)
```

---

## CLI 命令行接口

### cudasift

基本演示程序。读取图像对，提取 SIFT 特征并匹配。

```bash
cudasift [devNum] [imgSet]
```

| 参数 | 说明 |
|------|------|
| `devNum` | GPU 设备编号（默认 0） |
| `imgSet` | 图像集：`0` = img1.jpg/img2.jpg，`1` = left.pgm/righ.pgm |

### cudasift_txt

支持配置文件和可视化的增强版。

```bash
cudasift_txt [devNum] [imgSet] [configFile]
```

| 参数 | 说明 |
|------|------|
| `devNum` | GPU 设备编号（默认 0） |
| `imgSet` | 图像集选择（覆盖配置文件中的 `image_set`） |
| `configFile` | 配置文件路径（默认 `config/sift_config.txt`） |

```bash
# 示例
./cudasift_txt 0 1 config/test_config.txt
```
